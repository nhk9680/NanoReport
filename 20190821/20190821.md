# 20190821

## DONE

### python
- len(list)=n일 때, list[:n+a] == list[:n]
- `with torch.no_grad():` no gradient, 학습, 추적, 메모리 저장 안함
### MMDetection
- [`proposals = torch.cat([proposals, scores.unsqueeze(-1)], dim=-1)`]
    - tensor([1000,4]) 를 tensor([1000,5]) 로 늘려준다.
    - proposals[0]
        - before
        - `tensor([1059.0000,  0.0000,      1059.0000,  13.1144                 ], device='cuda:0')`
        - after
        - `tensor([1.0590e+03, 0.0000e+00,  1.0590e+03, 1.3114e+01, 5.6994e-01  ], device='cuda:0')`
    - 앞의 네 개는 [x1, y1, x2, y2] 이고, 뒤에 하나는 `scores`
- [`rois = bbox2roi(proposal_list)`](https://github.com/open-mmlab/mmdetection/blob/0b96173149603abed1feeea4fe814b9fab383787/mmdet/models/detectors/cascade_rcnn.py#L286)
    ```
    (Pdb) proposal_list[0][0]
    tensor([540.9440, 391.5113, 665.9113, 769.5121,   0.9999], device='cuda:0')
    (Pdb) rois[0]
    tensor([  0.0000, 540.9440, 391.5113, 665.9113, 769.5121], device='cuda:0')
    ```
    ```
    def bbox2roi(bbox_list):
        """Convert a list of bboxes to roi format.
        Args:
            bbox_list (list[Tensor]): a list of bboxes corresponding to a batch
                of images.
        Returns:
            Tensor: shape (n, 5), [batch_ind, x1, y1, x2, y2]
        """
    ```

- resutls=[ms_bbox_result, ms_segm_result]

- `bbox_result = bbox2result(det_bboxes, det_labels, bbox_head.num_classes)`

    ```
    def bbox2result(bboxes, labels, num_classes):
        """Convert detection results to a list of numpy arrays.
        Args:
            bboxes (Tensor): shape (n, 5)
            labels (Tensor): shape (n, )
            num_classes (int): class number, including background class
        Returns:
            list(ndarray): bbox results of each class
        """
        if bboxes.shape[0] == 0:
            return [
                np.zeros((0, 5), dtype=np.float32) for i in range(num_classes - 1)
            ]
        else:
            bboxes = bboxes.cpu().numpy()
            labels = labels.cpu().numpy()
            return [bboxes[labels == i, :] for i in range(num_classes - 1)]
    ```

    labels가 살아있는 bboxes만 살려서 넘김, 나머진 빈 값으로 넘김

    - [rle = mask_util.encode(np.array(im_mask[:, :, np.newaxis], order='F'))[0]](https://github.com/open-mmlab/mmdetection/blob/0b96173149603abed1feeea4fe814b9fab383787/mmdet/models/mask_heads/fcn_mask_head.py#L177)

    ```
    # encode mask to RLEs objects
    # list of RLE string can be generated by RLEs member function
    def encode(np.ndarray[np.uint8_t, ndim=3, mode='fortran'] mask):
        h, w, n = mask.shape[0], mask.shape[1], mask.shape[2]
        cdef RLEs Rs = RLEs(n)
        rleEncode(Rs._R,<byte*>mask.data,h,w,n)
        objs = _toString(Rs)
        return objs
    ```

    구한 segmentation을 pycocotools를 이용해 인코딩한다. 인코딩하기 전 모습은 (w,h,1) binary mask이다.

---
### irrelevant
- 대학원 포함 시간표 작성
---
## TODO
- `decode.py` 실행해서 복원해보기
- COCO와 VOC의 Segmentation format 비교
    - 다르면 COCO로 우선 뽑고 COCO2VOC 구글에 많으니 그거로 돌리기
- `.pkl`
- 시간표 최종결정하기
---
.

.

.

### TMI
기상시간 8:30

출근시각 11:50

날씨: 비


외출시간
- 점심식사 (2:30~4:00)
- 저녁식사 (5:30~7:30)

통학시간에 한 것
- 북학의 ~37p